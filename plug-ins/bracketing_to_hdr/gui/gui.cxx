// generated by Fast Light User Interface Designer (fluid) version 1.0108

#include "../br_core/i18n.hpp"
#include "gui.h"
#include "AllWindows.hpp"
#include "preferences.hpp"
#include "fl_translate_menu.cpp"
#include "../br_core/br_version.hpp"
#include "../br_core/WeightFuncBase.hpp"
#include "../br_core/Run_DisplcmFinder.hpp"
#include "../bracketing_to_hdr.hpp"
using namespace br;
static Br2HdrManager & theBr2Hdr = Br2Hdr::Instance(); 

void MainWinClass::cb_Open_i(Fl_Menu_*, void*) {
  load_input_images();
}
void MainWinClass::cb_Open(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Open_i(o,v);
}

void MainWinClass::cb_Clear_i(Fl_Menu_*, void*) {
  theBr2Hdr.clear_ContAndCalc();
}
void MainWinClass::cb_Clear(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Clear_i(o,v);
}

void MainWinClass::cb_Clear1_i(Fl_Menu_*, void*) {
  theBr2Hdr.clear_ResponseExtern();
allWins.response->update_after_clear_response_extern();
// assume, allWins.response exists !?;
}
void MainWinClass::cb_Clear1(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Clear1_i(o,v);
}

void MainWinClass::cb_Quit_i(Fl_Menu_*, void*) {
  window_->do_callback();
}
void MainWinClass::cb_Quit(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Quit_i(o,v);
}

void MainWinClass::cb_mbar_item_Init_Calctor__i(Fl_Menu_*, void*) {
  Br2Hdr::Instance().init_Calctor();
}
void MainWinClass::cb_mbar_item_Init_Calctor_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_Init_Calctor__i(o,v);
}

void MainWinClass::cb_mbar_item_Compute_Response__i(Fl_Menu_*, void*) {
  Br2Hdr::Instance().compute_Response();
}
void MainWinClass::cb_mbar_item_Compute_Response_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_Compute_Response__i(o,v);
}

void MainWinClass::cb_mbar_item_Compute_HDR__i(Fl_Menu_*, void*) {
  cpaint_show_image (Br2Hdr::Instance().complete_HDR());
}
void MainWinClass::cb_mbar_item_Compute_HDR_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_Compute_HDR__i(o,v);
}

void MainWinClass::cb_mbar_item_Compute_logHDR__i(Fl_Menu_*, void*) {
  cpaint_show_image (Br2Hdr::Instance().complete_LogHDR());
}
void MainWinClass::cb_mbar_item_Compute_logHDR_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_Compute_logHDR__i(o,v);
}

void MainWinClass::cb_Identity_i(Fl_Menu_*, void*) {
  theBr2Hdr.setWeightResp(WeightFuncBase::IDENTITY);
}
void MainWinClass::cb_Identity(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Identity_i(o,v);
}

void MainWinClass::cb_Identity1_i(Fl_Menu_*, void*) {
  theBr2Hdr.setWeightResp(WeightFuncBase::IDENTITY_0);
}
void MainWinClass::cb_Identity1(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Identity1_i(o,v);
}

void MainWinClass::cb_Triangle_i(Fl_Menu_*, void*) {
  theBr2Hdr.setWeightResp(WeightFuncBase::TRIANGLE);
}
void MainWinClass::cb_Triangle(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Triangle_i(o,v);
}

void MainWinClass::cb_Sinus_i(Fl_Menu_*, void*) {
  theBr2Hdr.setWeightResp(WeightFuncBase::SINUS);
}
void MainWinClass::cb_Sinus(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Sinus_i(o,v);
}

void MainWinClass::cb_Identity_0_Param_i(Fl_Menu_*, void*) {
  theBr2Hdr.setWeightResp(WeightFuncBase::IDENTITY_0_PARAM);
}
void MainWinClass::cb_Identity_0_Param(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Identity_0_Param_i(o,v);
}

void MainWinClass::cb_Triangle_Param_i(Fl_Menu_*, void*) {
  theBr2Hdr.setWeightResp(WeightFuncBase::TRIANGLE_PARAM);
}
void MainWinClass::cb_Triangle_Param(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Triangle_Param_i(o,v);
}

void MainWinClass::cb_Identity2_i(Fl_Menu_*, void*) {
  theBr2Hdr.setWeightMerge(WeightFuncBase::IDENTITY);
}
void MainWinClass::cb_Identity2(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Identity2_i(o,v);
}

void MainWinClass::cb_Identity3_i(Fl_Menu_*, void*) {
  theBr2Hdr.setWeightMerge(WeightFuncBase::IDENTITY_0);
}
void MainWinClass::cb_Identity3(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Identity3_i(o,v);
}

void MainWinClass::cb_Triangle1_i(Fl_Menu_*, void*) {
  theBr2Hdr.setWeightMerge(WeightFuncBase::TRIANGLE);
}
void MainWinClass::cb_Triangle1(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Triangle1_i(o,v);
}

void MainWinClass::cb_Sinus1_i(Fl_Menu_*, void*) {
  theBr2Hdr.setWeightMerge(WeightFuncBase::SINUS);
}
void MainWinClass::cb_Sinus1(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Sinus1_i(o,v);
}

void MainWinClass::cb_Identity_0_Param1_i(Fl_Menu_*, void*) {
  theBr2Hdr.setWeightMerge(WeightFuncBase::IDENTITY_0_PARAM);
}
void MainWinClass::cb_Identity_0_Param1(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Identity_0_Param1_i(o,v);
}

void MainWinClass::cb_Triangle_Param1_i(Fl_Menu_*, void*) {
  theBr2Hdr.setWeightMerge(WeightFuncBase::TRIANGLE_PARAM);
}
void MainWinClass::cb_Triangle_Param1(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Triangle_Param1_i(o,v);
}

void MainWinClass::cb_Images_i(Fl_Menu_*, void*) {
  theBr2Hdr.report_Images();
}
void MainWinClass::cb_Images(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Images_i(o,v);
}

void MainWinClass::cb_Numerics_i(Fl_Menu_*, void*) {
  theBr2Hdr.report_NumericParams();
}
void MainWinClass::cb_Numerics(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Numerics_i(o,v);
}

void MainWinClass::cb_Calctor_i(Fl_Menu_*, void*) {
  theBr2Hdr.report_CalctorParams();
}
void MainWinClass::cb_Calctor(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Calctor_i(o,v);
}

void MainWinClass::cb_Indices_i(Fl_Menu_*, void*) {
  theBr2Hdr.report_Indices();
}
void MainWinClass::cb_Indices(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Indices_i(o,v);
}

void MainWinClass::cb_Pack_i(Fl_Menu_*, void*) {
  if (theBr2Hdr.calctor())
  theBr2Hdr.calctor()->packBase().report();
}
void MainWinClass::cb_Pack(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Pack_i(o,v);
}

void MainWinClass::cb_Status_i(Fl_Menu_*, void*) {
  theBr2Hdr.report_StatusResponseCurves();
}
void MainWinClass::cb_Status(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Status_i(o,v);
}

void MainWinClass::cb_Weight_i(Fl_Menu_*, void*) {
  theBr2Hdr.report_WeightFunc();
}
void MainWinClass::cb_Weight(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Weight_i(o,v);
}

void MainWinClass::cb_Offsets_i(Fl_Menu_*, void*) {
  theBr2Hdr.imgVector().report_offsets();
}
void MainWinClass::cb_Offsets(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Offsets_i(o,v);
}

void MainWinClass::cb_Intersection_i(Fl_Menu_*, void*) {
  theBr2Hdr.imgVector().report_intersection();
}
void MainWinClass::cb_Intersection(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Intersection_i(o,v);
}

void MainWinClass::cb_Follow_i(Fl_Menu_*, void*) {
  allWins.do_followUp();
}
void MainWinClass::cb_Follow(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Follow_i(o,v);
}

void MainWinClass::cb_Response_i(Fl_Menu_*, void*) {
  allWins.do_response();
}
void MainWinClass::cb_Response(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Response_i(o,v);
}

void MainWinClass::cb_Histogram_i(Fl_Menu_*, void*) {
  allWins.do_histogram();
}
void MainWinClass::cb_Histogram(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Histogram_i(o,v);
}

void MainWinClass::cb_Displacements_i(Fl_Menu_*, void*) {
  //allWins.do_displacements();
}
void MainWinClass::cb_Displacements(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Displacements_i(o,v);
}

void MainWinClass::cb_Offset_i(Fl_Menu_*, void*) {
  allWins.do_displcmFinderUI();
}
void MainWinClass::cb_Offset(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Offset_i(o,v);
}

void MainWinClass::cb_TestSuite_i(Fl_Menu_*, void*) {
  allWins.do_testSuite();
}
void MainWinClass::cb_TestSuite(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_TestSuite_i(o,v);
}

void MainWinClass::cb_EventDebugger_i(Fl_Menu_*, void*) {
  allWins.do_eventTester();
}
void MainWinClass::cb_EventDebugger(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_EventDebugger_i(o,v);
}

void MainWinClass::cb_mbar_item_timesbar__i(Fl_Menu_*, void*) {
  if (mbar_item_timesbar_->value()) 
     timesbar_on();
else timesbar_off();
}
void MainWinClass::cb_mbar_item_timesbar_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_timesbar__i(o,v);
}

void MainWinClass::cb_mbar_item_offsetbar__i(Fl_Menu_*, void*) {
  if (mbar_item_offsetbar_->value()) 
     offsetbar_on();
else offsetbar_off();
}
void MainWinClass::cb_mbar_item_offsetbar_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_offsetbar__i(o,v);
}

void MainWinClass::cb_mbar_item_auto_update_followup__i(Fl_Menu_*, void*) {
  theBr2Hdr.setAutoUpdateFollowUp(mbar_item_auto_update_followup_->value());
}
void MainWinClass::cb_mbar_item_auto_update_followup_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_auto_update_followup__i(o,v);
}

void MainWinClass::cb_mbar_item_solvemode_auto__i(Fl_Menu_*, void*) {
  theBr2Hdr.solve_mode(ResponseSolverBase::AUTO);
}
void MainWinClass::cb_mbar_item_solvemode_auto_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_solvemode_auto__i(o,v);
}

void MainWinClass::cb_mbar_item_solvemode_use_qr__i(Fl_Menu_*, void*) {
  theBr2Hdr.solve_mode(ResponseSolverBase::USE_QR);
}
void MainWinClass::cb_mbar_item_solvemode_use_qr_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_solvemode_use_qr__i(o,v);
}

void MainWinClass::cb_mbar_item_solvemode_use_svd__i(Fl_Menu_*, void*) {
  theBr2Hdr.solve_mode(ResponseSolverBase::USE_SVD);
}
void MainWinClass::cb_mbar_item_solvemode_use_svd_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_solvemode_use_svd__i(o,v);
}

void MainWinClass::cb_testmode_i(Fl_Menu_*, void*) {
  theBr2Hdr.solve_mode(ResponseSolverBase::TEST_BOTH);
}
void MainWinClass::cb_testmode(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_testmode_i(o,v);
}

void MainWinClass::cb_mbar_item_methodZ_refpic__i(Fl_Menu_*, void*) {
  theBr2Hdr.method_Z(1);
}
void MainWinClass::cb_mbar_item_methodZ_refpic_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_methodZ_refpic__i(o,v);
}

void MainWinClass::cb_mbar_item_methodZ_overlap__i(Fl_Menu_*, void*) {
  theBr2Hdr.method_Z(2);
}
void MainWinClass::cb_mbar_item_methodZ_overlap_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_methodZ_overlap__i(o,v);
}

void MainWinClass::cb_mbar_item_enforce_refresh__i(Fl_Menu_*, void*) {
  progress_resizing_support(mbar_item_enforce_refresh_->value());
printf("support = %d\n", progress_resizing_support());
}
void MainWinClass::cb_mbar_item_enforce_refresh_(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_mbar_item_enforce_refresh__i(o,v);
}

void MainWinClass::cb_Save_i(Fl_Menu_*, void*) {
  write_preferences();
}
void MainWinClass::cb_Save(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Save_i(o,v);
}

void MainWinClass::cb_Default_i(Fl_Menu_*, void*) {
  default_settings();
}
void MainWinClass::cb_Default(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Default_i(o,v);
}

void MainWinClass::cb_Reset_i(Fl_Menu_*, void*) {
  allWins.reset_win_positions();
}
void MainWinClass::cb_Reset(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_Reset_i(o,v);
}

void MainWinClass::cb_About_i(Fl_Menu_*, void*) {
  allWins.do_helpAbout();
}
void MainWinClass::cb_About(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_About_i(o,v);
}

void MainWinClass::cb_HDR_i(Fl_Menu_*, void*) {
  allWins.do_helpTutorial();
}
void MainWinClass::cb_HDR(Fl_Menu_* o, void* v) {
  ((MainWinClass*)(o->parent()->user_data()))->cb_HDR_i(o,v);
}

Fl_Menu_Item MainWinClass::menu_menubar_[] = {
 {_("&File"), 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Open Image(s)..."), 0x8006f,  (Fl_Callback*)MainWinClass::cb_Open, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Clear Image Container"), 0,  (Fl_Callback*)MainWinClass::cb_Clear, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Clear external response curves"), 0,  (Fl_Callback*)MainWinClass::cb_Clear1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Quit"), 0,  (Fl_Callback*)MainWinClass::cb_Quit, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {_("Make"), 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Init Calctor"), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_Init_Calctor_, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Compute Response "), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_Compute_Response_, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Compute HDR"), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_Compute_HDR_, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Compute log HDR"), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_Compute_logHDR_, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Weight curve \'Response comp.\'"), 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Identity"), 0,  (Fl_Callback*)MainWinClass::cb_Identity, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Identity with 0-borders"), 0,  (Fl_Callback*)MainWinClass::cb_Identity1, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Triangle"), 0,  (Fl_Callback*)MainWinClass::cb_Triangle, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Sinus"), 0,  (Fl_Callback*)MainWinClass::cb_Sinus, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Identity_0_Param"), 0,  (Fl_Callback*)MainWinClass::cb_Identity_0_Param, 0, 24, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Triangle_Param"), 0,  (Fl_Callback*)MainWinClass::cb_Triangle_Param, 0, 24, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {_("Weight curve \'HDR merging\'"), 0,  0, 0, 192, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Identity"), 0,  (Fl_Callback*)MainWinClass::cb_Identity2, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Identity with 0-borders"), 0,  (Fl_Callback*)MainWinClass::cb_Identity3, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Triangle"), 0,  (Fl_Callback*)MainWinClass::cb_Triangle1, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Sinus"), 0,  (Fl_Callback*)MainWinClass::cb_Sinus1, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Identity_0_Param"), 0,  (Fl_Callback*)MainWinClass::cb_Identity_0_Param1, 0, 24, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Triangle_Param"), 0,  (Fl_Callback*)MainWinClass::cb_Triangle_Param1, 0, 24, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {_("Report  (console)"), 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Images"), 0,  (Fl_Callback*)MainWinClass::cb_Images, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Numerics"), 0,  (Fl_Callback*)MainWinClass::cb_Numerics, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Calctor\'s Numerics"), 0,  (Fl_Callback*)MainWinClass::cb_Calctor, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Indices"), 0,  (Fl_Callback*)MainWinClass::cb_Indices, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Pack"), 0,  (Fl_Callback*)MainWinClass::cb_Pack, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Status Response Curves"), 0,  (Fl_Callback*)MainWinClass::cb_Status, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Weight Functions"), 0,  (Fl_Callback*)MainWinClass::cb_Weight, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Offsets"), 0,  (Fl_Callback*)MainWinClass::cb_Offsets, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Intersection area"), 0,  (Fl_Callback*)MainWinClass::cb_Intersection, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0},
 {_("&Tools"), 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Follow-up Curves..."), 0,  (Fl_Callback*)MainWinClass::cb_Follow, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Response Curves..."), 0,  (Fl_Callback*)MainWinClass::cb_Response, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Histogram..."), 0,  (Fl_Callback*)MainWinClass::cb_Histogram, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Displacements"), 0,  (Fl_Callback*)MainWinClass::cb_Displacements, 0, 145, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Offset Computation..."), 0,  (Fl_Callback*)MainWinClass::cb_Offset, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {_("TestSuite..."), 0,  (Fl_Callback*)MainWinClass::cb_TestSuite, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("EventDebugger..."), 0,  (Fl_Callback*)MainWinClass::cb_EventDebugger, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {_("Numerics"), 0,  0, 0, 81, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Pack-Format"), 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Single Images + interleave"), 0,  0, 0, 12, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Channel-wise"), 0,  0, 0, 9, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0},
 {_("Settings"), 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Show time setting bar"), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_timesbar_, 0, 6, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Show Offset bar"), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_offsetbar_, 0, 6, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Auto-update follow-up curves"), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_auto_update_followup_, 0, 6, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Auto-load last external response curves at start"), 0,  0, 0, 6, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Downsample 16-bit input images"), 0,  0, 0, 130, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Method for solving the least square fit"), 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {_("auto (try QR; if rank defect use SVD)"), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_solvemode_auto_, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {_("QR (abborts if rank defect)"), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_solvemode_use_qr_, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {_("SVD (a bit faster than \'auto\' if QR fails)"), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_solvemode_use_svd_, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {_("testmode (QR + SVD + compare)"), 0,  (Fl_Callback*)MainWinClass::cb_testmode, 0, 25, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {_("Method for Z-Matrix generation"), 0,  0, 0, 192, FL_NORMAL_LABEL, 0, 14, 0},
 {_("selection along refpic line (recommended!)"), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_methodZ_refpic_, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {_("overlapp criterion (default until version 0.5.1)"), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_methodZ_overlap_, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {_("Enforce progress refreshes"), 0,  (Fl_Callback*)MainWinClass::cb_mbar_item_enforce_refresh_, 0, 19, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Auto-save settings at plug-in end"), 0,  0, 0, 130, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Save current settings"), 0,  (Fl_Callback*)MainWinClass::cb_Save, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Default settings"), 0,  (Fl_Callback*)MainWinClass::cb_Default, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Reset window positions"), 0,  (Fl_Callback*)MainWinClass::cb_Reset, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {_("Help"), 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {_("About..."), 0,  (Fl_Callback*)MainWinClass::cb_About, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("HDR-Tutorial...."), 0,  (Fl_Callback*)MainWinClass::cb_HDR, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};
Fl_Menu_Item* MainWinClass::mbar_item_Init_Calctor_ = MainWinClass::menu_menubar_ + 7;
Fl_Menu_Item* MainWinClass::mbar_item_Compute_Response_ = MainWinClass::menu_menubar_ + 8;
Fl_Menu_Item* MainWinClass::mbar_item_Compute_HDR_ = MainWinClass::menu_menubar_ + 9;
Fl_Menu_Item* MainWinClass::mbar_item_Compute_logHDR_ = MainWinClass::menu_menubar_ + 10;
Fl_Menu_Item* MainWinClass::mbar_item_timesbar_ = MainWinClass::menu_menubar_ + 55;
Fl_Menu_Item* MainWinClass::mbar_item_offsetbar_ = MainWinClass::menu_menubar_ + 56;
Fl_Menu_Item* MainWinClass::mbar_item_auto_update_followup_ = MainWinClass::menu_menubar_ + 57;
Fl_Menu_Item* MainWinClass::mbar_item_auto_load_response_ = MainWinClass::menu_menubar_ + 58;
Fl_Menu_Item* MainWinClass::mbar_item_downsample_U16_ = MainWinClass::menu_menubar_ + 59;
Fl_Menu_Item* MainWinClass::mbar_item_solvemode_auto_ = MainWinClass::menu_menubar_ + 61;
Fl_Menu_Item* MainWinClass::mbar_item_solvemode_use_qr_ = MainWinClass::menu_menubar_ + 62;
Fl_Menu_Item* MainWinClass::mbar_item_solvemode_use_svd_ = MainWinClass::menu_menubar_ + 63;
Fl_Menu_Item* MainWinClass::mbar_item_methodZ_refpic_ = MainWinClass::menu_menubar_ + 67;
Fl_Menu_Item* MainWinClass::mbar_item_methodZ_overlap_ = MainWinClass::menu_menubar_ + 68;
Fl_Menu_Item* MainWinClass::mbar_item_enforce_refresh_ = MainWinClass::menu_menubar_ + 70;
Fl_Menu_Item* MainWinClass::mbar_item_auto_save_prefs_ = MainWinClass::menu_menubar_ + 71;

void MainWinClass::cb_radio_timesByEXIF__i(Fl_Round_Button*, void*) {
  theBr2Hdr.timesSetting(Br2Hdr::BY_EXIF);
theBr2Hdr.setTimes();
stopvalueChoicer_->deactivate();
}
void MainWinClass::cb_radio_timesByEXIF_(Fl_Round_Button* o, void* v) {
  ((MainWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_radio_timesByEXIF__i(o,v);
}

void MainWinClass::cb_radio_timesByStop__i(Fl_Round_Button*, void*) {
  theBr2Hdr.timesSetting(Br2Hdr::BY_STOP);
theBr2Hdr.forActiveTimes(false);
theBr2Hdr.setTimes();
stopvalueChoicer_->activate();
}
void MainWinClass::cb_radio_timesByStop_(Fl_Round_Button* o, void* v) {
  ((MainWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_radio_timesByStop__i(o,v);
}

void MainWinClass::cb_radio_timesActiveByStop__i(Fl_Round_Button*, void*) {
  theBr2Hdr.timesSetting(Br2Hdr::BY_STOP);
theBr2Hdr.forActiveTimes(true);
theBr2Hdr.setTimes();
stopvalueChoicer_->activate();
}
void MainWinClass::cb_radio_timesActiveByStop_(Fl_Round_Button* o, void* v) {
  ((MainWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_radio_timesActiveByStop__i(o,v);
}

void MainWinClass::cb_tggl_normedTimes__i(Fl_Check_Button* o, void*) {
  theBr2Hdr.normedTimes(o->value());
theBr2Hdr.setTimes();
}
void MainWinClass::cb_tggl_normedTimes_(Fl_Check_Button* o, void* v) {
  ((MainWinClass*)(o->parent()->parent()->user_data()))->cb_tggl_normedTimes__i(o,v);
}

void MainWinClass::cb_bttn_use_offsets__i(Fl_Check_Button* o, void*) {
  theBr2Hdr.use_offsets(o->value());
}
void MainWinClass::cb_bttn_use_offsets_(Fl_Check_Button* o, void* v) {
  ((MainWinClass*)(o->parent()->parent()->user_data()))->cb_bttn_use_offsets__i(o,v);
}

void MainWinClass::cb_Compute_i(ComputeOffsetsButton*, void*) {
  the_tab_->value(tab_offsets_);
Run_DisplcmFinder::run_for_all_actives();
theBr2Hdr.use_offsets(true);
bttn_use_offsets_->value(1);
}
void MainWinClass::cb_Compute(ComputeOffsetsButton* o, void* v) {
  ((MainWinClass*)(o->parent()->parent()->user_data()))->cb_Compute_i(o,v);
}

void MainWinClass::cb_M_i(Fl_Button* o, void*) {
  theBr2Hdr.mark_bad_pixel(o->value());
}
void MainWinClass::cb_M(Fl_Button* o, void* v) {
  ((MainWinClass*)(o->parent()->parent()->user_data()))->cb_M_i(o,v);
}
//MainWinMenubarWatcher  menubar_watcher;

MainWinClass::MainWinClass() {
  { window_ = new Fl_Double_Window(485, 410, _("Bracketing to HDR"));
    window_->user_data((void*)(this));
    { Fl_Menu_Bar* o = menubar_ = new Fl_Menu_Bar(0, 0, 485, 30);
      menubar_->when(FL_WHEN_RELEASE);
      { Fl_Menu_Item* o = &menu_menubar_[12];
        if (theBr2Hdr.weightShapeResp()==WeightFuncBase::IDENTITY) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[13];
        if (theBr2Hdr.weightShapeResp()==WeightFuncBase::IDENTITY_0) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[14];
        if (theBr2Hdr.weightShapeResp()==WeightFuncBase::TRIANGLE) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[15];
        if (theBr2Hdr.weightShapeResp()==WeightFuncBase::SINUS) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[16];
        if (theBr2Hdr.weightShapeResp()==WeightFuncBase::IDENTITY_0_PARAM) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[17];
        if (theBr2Hdr.weightShapeResp()==WeightFuncBase::TRIANGLE_PARAM) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[20];
        if (theBr2Hdr.weightShapeMerge()==WeightFuncBase::IDENTITY) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[21];
        if (theBr2Hdr.weightShapeMerge()==WeightFuncBase::IDENTITY_0) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[22];
        if (theBr2Hdr.weightShapeMerge()==WeightFuncBase::TRIANGLE) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[23];
        if (theBr2Hdr.weightShapeMerge()==WeightFuncBase::SINUS) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[24];
        if (theBr2Hdr.weightShapeMerge()==WeightFuncBase::IDENTITY_0_PARAM) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[25];
        if (theBr2Hdr.weightShapeMerge()==WeightFuncBase::TRIANGLE_PARAM) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[57];
        if (theBr2Hdr.isAutoUpdateFollowUp()) o->set(); else o->clear();
      }
      { Fl_Menu_Item* o = &menu_menubar_[61];
        if (theBr2Hdr.solve_mode()==ResponseSolverBase::AUTO) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[62];
        if (theBr2Hdr.solve_mode()==ResponseSolverBase::USE_QR) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[63];
        if (theBr2Hdr.solve_mode()==ResponseSolverBase::USE_SVD) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[64];
        if (theBr2Hdr.solve_mode()==ResponseSolverBase::TEST_BOTH) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[67];
        if (theBr2Hdr.method_Z()==1) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[68];
        if (theBr2Hdr.method_Z()==2) o->setonly();
      }
      { Fl_Menu_Item* o = &menu_menubar_[70];
        if (progress_resizing_support()) o->set(); else o->clear();
      }
      menubar_->menu(menu_menubar_);
      fl_translate_menu ((Fl_Menu_Item*)o->menu());
    } // Fl_Menu_Bar* menubar_
    { Fl_Tabs* o = the_tab_ = new Fl_Tabs(0, 35, 485, 255);
      the_tab_->selection_color(FL_BACKGROUND2_COLOR);
      { tab_images_ = new Fl_Group(0, 60, 485, 230, _("Images"));
        tab_images_->tooltip(_("Table of input images, ordered by average brightness per pixel. Column \'Brig\
htness\' shows the relative brightness compared to the darkest image. Column \
\'Wk-Range\' shows the percentage of pixels within the working range."));
        tab_images_->hide();
        { table_images_ = new ImageTable(0, 65, 485, 224);
          table_images_->box(FL_NO_BOX);
          table_images_->color(FL_BACKGROUND_COLOR);
          table_images_->selection_color(FL_BACKGROUND_COLOR);
          table_images_->labeltype(FL_NORMAL_LABEL);
          table_images_->labelfont(0);
          table_images_->labelsize(14);
          table_images_->labelcolor(FL_FOREGROUND_COLOR);
          table_images_->align(FL_ALIGN_TOP);
          table_images_->when(FL_WHEN_RELEASE);
          table_images_->end();
          Fl_Group::current()->resizable(table_images_);
        } // ImageTable* table_images_
        tab_images_->end();
        Fl_Group::current()->resizable(tab_images_);
      } // Fl_Group* tab_images_
      { tab_exif_ = new Fl_Group(0, 60, 485, 230, _("EXIF"));
        { table_exif_ = new ExifTable(0, 65, 485, 224);
          table_exif_->box(FL_NO_BOX);
          table_exif_->color(FL_BACKGROUND_COLOR);
          table_exif_->selection_color(FL_BACKGROUND_COLOR);
          table_exif_->labeltype(FL_NORMAL_LABEL);
          table_exif_->labelfont(0);
          table_exif_->labelsize(14);
          table_exif_->labelcolor(FL_FOREGROUND_COLOR);
          table_exif_->align(FL_ALIGN_TOP);
          table_exif_->when(FL_WHEN_RELEASE);
          table_exif_->end();
        } // ExifTable* table_exif_
        tab_exif_->end();
      } // Fl_Group* tab_exif_
      { tab_offsets_ = new Fl_Group(0, 60, 485, 230, _("Offsets"));
        tab_offsets_->tooltip(_("Offset of the images. Column 1 lists the computed value - computed against th\
e image at position \"to pos\". Column 3 shows the global offset relative to t\
he first active image."));
        tab_offsets_->hide();
        { table_offsets_ = new OffsetTable(0, 65, 485, 224);
          table_offsets_->box(FL_NO_BOX);
          table_offsets_->color(FL_BACKGROUND_COLOR);
          table_offsets_->selection_color(FL_BACKGROUND_COLOR);
          table_offsets_->labeltype(FL_NORMAL_LABEL);
          table_offsets_->labelfont(0);
          table_offsets_->labelsize(14);
          table_offsets_->labelcolor(FL_FOREGROUND_COLOR);
          table_offsets_->align(FL_ALIGN_TOP);
          table_offsets_->when(FL_WHEN_RELEASE);
          table_offsets_->end();
        } // OffsetTable* table_offsets_
        tab_offsets_->end();
      } // Fl_Group* tab_offsets_
      o->value(o->child(0)); // activate the first
      the_tab_->end();
      Fl_Group::current()->resizable(the_tab_);
    } // Fl_Tabs* the_tab_
    { Fl_Group* o = grp_timesbar_ = new Fl_Group(0, 290, 485, 30);
      { new Fl_Box(10, 294, 65, 20, _("Times by:"));
      } // Fl_Box* o
      { Fl_Group* o = new Fl_Group(75, 294, 250, 21);
        { radio_timesByEXIF_ = new Fl_Round_Button(85, 294, 60, 20, _("EXIF"));
          radio_timesByEXIF_->tooltip(_("Determines exposure times from the EXIF data. For shutter speeds = 0 result t\
imes = 0!"));
          radio_timesByEXIF_->type(102);
          radio_timesByEXIF_->down_box(FL_ROUND_DOWN_BOX);
          radio_timesByEXIF_->callback((Fl_Callback*)cb_radio_timesByEXIF_);
          radio_timesByEXIF_->when(FL_WHEN_RELEASE_ALWAYS);
        } // Fl_Round_Button* radio_timesByEXIF_
        { radio_timesByStop_ = new Fl_Round_Button(150, 294, 65, 20, _("Stops"));
          radio_timesByStop_->tooltip(_("Generates times for all images using the current \"stops\" value."));
          radio_timesByStop_->type(102);
          radio_timesByStop_->down_box(FL_ROUND_DOWN_BOX);
          radio_timesByStop_->callback((Fl_Callback*)cb_radio_timesByStop_);
          radio_timesByStop_->when(FL_WHEN_RELEASE_ALWAYS);
        } // Fl_Round_Button* radio_timesByStop_
        { radio_timesActiveByStop_ = new Fl_Round_Button(220, 294, 105, 20, _("Stops active"));
          radio_timesActiveByStop_->tooltip(_("Generates times for the *activated* images using the current \"stops\" value."));
          radio_timesActiveByStop_->type(102);
          radio_timesActiveByStop_->down_box(FL_ROUND_DOWN_BOX);
          radio_timesActiveByStop_->callback((Fl_Callback*)cb_radio_timesActiveByStop_);
          radio_timesActiveByStop_->when(FL_WHEN_RELEASE_ALWAYS);
        } // Fl_Round_Button* radio_timesActiveByStop_
        o->end();
      } // Fl_Group* o
      { stopvalueChoicer_ = new StopvalueChoicer(330, 294, 70, 20);
        stopvalueChoicer_->box(FL_FLAT_BOX);
        stopvalueChoicer_->down_box(FL_BORDER_BOX);
        stopvalueChoicer_->color(FL_BACKGROUND_COLOR);
        stopvalueChoicer_->selection_color(FL_SELECTION_COLOR);
        stopvalueChoicer_->labeltype(FL_NORMAL_LABEL);
        stopvalueChoicer_->labelfont(0);
        stopvalueChoicer_->labelsize(14);
        stopvalueChoicer_->labelcolor(FL_FOREGROUND_COLOR);
        stopvalueChoicer_->align(FL_ALIGN_LEFT);
        stopvalueChoicer_->when(FL_WHEN_RELEASE_ALWAYS);
      } // StopvalueChoicer* stopvalueChoicer_
      { tggl_normedTimes_ = new Fl_Check_Button(410, 294, 75, 20, _("normed"));
        tggl_normedTimes_->tooltip(_("Scales times so, that the first time of a series becomes 1."));
        tggl_normedTimes_->down_box(FL_DOWN_BOX);
        tggl_normedTimes_->value(1);
        tggl_normedTimes_->callback((Fl_Callback*)cb_tggl_normedTimes_);
      } // Fl_Check_Button* tggl_normedTimes_
      { Fl_Box* o = new Fl_Box(0, 318, 485, 2);
        o->box(FL_ENGRAVED_BOX);
      } // Fl_Box* o
      h_timesbar_ = o->h(); // FLUID's h. as target h.
      grp_timesbar_->end();
    } // Fl_Group* grp_timesbar_
    { Fl_Group* o = grp_offsetbar_ = new Fl_Group(0, 320, 485, 30);
      { Fl_Check_Button* o = bttn_use_offsets_ = new Fl_Check_Button(155, 324, 175, 20, _("use offsets"));
        bttn_use_offsets_->tooltip(_("If checked, computed offsets are used in HDR calculator initalisation."));
        bttn_use_offsets_->down_box(FL_DOWN_BOX);
        bttn_use_offsets_->callback((Fl_Callback*)cb_bttn_use_offsets_);
        if (theBr2Hdr.use_offsets()) o->set(); else o->clear();
      } // Fl_Check_Button* bttn_use_offsets_
      { ComputeOffsetsButton* o = new ComputeOffsetsButton(5, 324, 140, 20, _("Compute Offsets"));
        o->tooltip(_("Computes offsets (displacements) for all activated images."));
        o->box(FL_UP_BOX);
        o->color(FL_BACKGROUND_COLOR);
        o->selection_color(FL_BACKGROUND_COLOR);
        o->labeltype(FL_NORMAL_LABEL);
        o->labelfont(0);
        o->labelsize(14);
        o->labelcolor(FL_FOREGROUND_COLOR);
        o->callback((Fl_Callback*)cb_Compute);
        o->align(FL_ALIGN_CENTER);
        o->when(FL_WHEN_RELEASE);
        o->extra_init();
      } // ComputeOffsetsButton* o
      { Fl_Box* o = new Fl_Box(0, 348, 485, 2);
        o->box(FL_ENGRAVED_BOX);
      } // Fl_Box* o
      h_offsetbar_ = o->h(); // FLUID's h. as target h.
      grp_offsetbar_->end();
    } // Fl_Group* grp_offsetbar_
    { Fl_Group* o = new Fl_Group(0, 355, 485, 25);
      { InitCalctorButton* o = new InitCalctorButton(5, 355, 90, 25, _("Init"));
        o->tooltip(_("Init the HDR-Calculator with the activated input images"));
        o->box(FL_UP_BOX);
        o->color(FL_BACKGROUND_COLOR);
        o->selection_color(FL_BACKGROUND_COLOR);
        o->labeltype(FL_NORMAL_LABEL);
        o->labelfont(0);
        o->labelsize(14);
        o->labelcolor(FL_FOREGROUND_COLOR);
        o->align(FL_ALIGN_CENTER);
        o->when(FL_WHEN_RELEASE);
        o->extra_init();
      } // InitCalctorButton* o
      { ComputeResponseButton* o = bttn_init_calctor_ = new ComputeResponseButton(110, 355, 140, 25, _("Compute Response"));
        bttn_init_calctor_->tooltip(_("Compute the response curves"));
        bttn_init_calctor_->box(FL_UP_BOX);
        bttn_init_calctor_->color(FL_BACKGROUND_COLOR);
        bttn_init_calctor_->selection_color(FL_BACKGROUND_COLOR);
        bttn_init_calctor_->labeltype(FL_NORMAL_LABEL);
        bttn_init_calctor_->labelfont(0);
        bttn_init_calctor_->labelsize(14);
        bttn_init_calctor_->labelcolor(FL_FOREGROUND_COLOR);
        bttn_init_calctor_->align(FL_ALIGN_CENTER);
        bttn_init_calctor_->when(FL_WHEN_RELEASE);
        o->extra_init();
      } // ComputeResponseButton* bttn_init_calctor_
      { HDRButton* o = new HDRButton(250, 355, 70, 25, _("HDR"));
        o->tooltip(_("Assemble the HDR image using the \"using next\" response curves. If they are \
incomplete, they are computed before, except \"use external curves\" is on."));
        o->box(FL_UP_BOX);
        o->color(FL_BACKGROUND_COLOR);
        o->selection_color(FL_BACKGROUND_COLOR);
        o->labeltype(FL_NORMAL_LABEL);
        o->labelfont(0);
        o->labelsize(14);
        o->labelcolor(FL_FOREGROUND_COLOR);
        o->align(FL_ALIGN_CENTER);
        o->when(FL_WHEN_RELEASE);
        o->extra_init();
      } // HDRButton* o
      { Fl_Button* o = new Fl_Button(320, 355, 25, 25, _("M"));
        o->tooltip(_("Mark cropped (zero-weighted, unresolved) HDR-values by contrast colors"));
        o->type(1);
        o->selection_color((Fl_Color)92);
        o->callback((Fl_Callback*)cb_M);
        o->value(theBr2Hdr.mark_bad_pixel());
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    { StatusLine* o = new StatusLine(0, 385, 485, 25);
      o->box(FL_THIN_DOWN_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_SELECTION_COLOR);
      o->labeltype(FL_NORMAL_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor(FL_FOREGROUND_COLOR);
      o->align(FL_ALIGN_LEFT);
      o->when(FL_WHEN_NEVER);
      theBr2Hdr.set_statusline(o);
    } // StatusLine* o
    { TheProgressBar* o = new TheProgressBar(0, 385, 485, 25);
      o->box(FL_THIN_DOWN_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_YELLOW);
      o->labeltype(FL_NORMAL_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor(FL_FOREGROUND_COLOR);
      o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
      o->when(FL_WHEN_RELEASE);
      o->with_cursor(true);
    } // TheProgressBar* o
    window_->end();
  } // Fl_Double_Window* window_
// Here we realize Properties default values:
  if (!mbar_item_offsetbar_->value()) offsetbar_off();
  if (!mbar_item_timesbar_->value()) timesbar_off();
}

MainWinClass::~MainWinClass() {
  delete window_;
}

void MainWinClass::show() {
  window_->show();
}

Fl_Window* MainWinClass::window() {
  return window_;
}

bool MainWinClass::downsample_U16() {
  return mbar_item_downsample_U16_->value();
}

void MainWinClass::method_Z(int m) {
  theBr2Hdr.method_Z(m);
switch(m) {
 case 1: mbar_item_methodZ_refpic_->setonly(); break;
 case 2: mbar_item_methodZ_overlap_->setonly(); break;
 default: ;
}
}

void MainWinClass::offsetbar_on() {
  if (grp_offsetbar_->visible()) return;
Fl_Window* w = window_;
Fl_Widget* save = w->resizable();
w->init_sizes();
w->resizable(grp_offsetbar_);
w->size(w->w(), w->h()+h_offsetbar_-1);
grp_offsetbar_->set_visible();
w->init_sizes();
w->resizable(save);
}

void MainWinClass::offsetbar_off() {
  if (!grp_offsetbar_->visible()) return;
Fl_Window* w = window_;
Fl_Widget* save = w->resizable();
w->init_sizes();
w->resizable(grp_offsetbar_);
grp_offsetbar_->hide();
w->size(w->w(), w->h()-h_offsetbar_+1);
w->init_sizes();
w->resizable(save);
}

void MainWinClass::timesbar_on() {
  //printf("TIMESBAR_ON()\n");
if (grp_timesbar_->visible()) return;
Fl_Window* w = window_;
Fl_Widget* save = w->resizable();
w->init_sizes();
w->resizable(grp_timesbar_);
w->size(w->w(), w->h()+h_timesbar_-1);
grp_timesbar_->set_visible();
w->init_sizes();
w->resizable(save);
}

void MainWinClass::timesbar_off() {
  //printf("TIMESBAR_OFF()\n");
if (!grp_timesbar_->visible()) return;
Fl_Window* w = window_;
Fl_Widget* save = w->resizable();
w->init_sizes();
w->resizable(grp_timesbar_);
grp_timesbar_->hide();
w->size(w->w(), w->h()-h_timesbar_+1);
w->init_sizes();
w->resizable(save);
}

bool MainWinClass::is_show_offset_buttons() const {
  return mbar_item_offsetbar_->value();
}

void MainWinClass::set_show_offset_buttons(bool b) {
  if (b) mbar_item_offsetbar_->set();
else   mbar_item_offsetbar_->clear();
mbar_item_offsetbar_->do_callback(menubar_);
}

bool MainWinClass::is_auto_load_response() const {
  return mbar_item_auto_load_response_->value();
}

void MainWinClass::set_auto_load_response(bool b) {
  if (b) mbar_item_auto_load_response_->set();
else   mbar_item_auto_load_response_->clear();
}

bool MainWinClass::is_auto_save_prefs() const {
  return mbar_item_auto_save_prefs_->value();
}

void MainWinClass::set_auto_save_prefs(bool b) {
  if (b) mbar_item_auto_save_prefs_->set();
else   mbar_item_auto_save_prefs_->clear();
}

void MainWinClass::set_auto_update_followup(bool b) {
  if (b) mbar_item_auto_update_followup_->set();
else   mbar_item_auto_update_followup_->clear();
}

void ResponseWinClass::cb_slider_grid_points__i(Fl_Value_Slider* o, void*) {
  theBr2Hdr.set_nSelectPoints(int(o->value()+0.5));
}
void ResponseWinClass::cb_slider_grid_points_(Fl_Value_Slider* o, void* v) {
  ((ResponseWinClass*)(o->parent()->parent()->user_data()))->cb_slider_grid_points__i(o,v);
}

void ResponseWinClass::cb_slider_smoothing__i(Fl_Value_Slider* o, void*) {
  theBr2Hdr.set_smoothing(o->value());
}
void ResponseWinClass::cb_slider_smoothing_(Fl_Value_Slider* o, void* v) {
  ((ResponseWinClass*)(o->parent()->parent()->user_data()))->cb_slider_smoothing__i(o,v);
}

void ResponseWinClass::cb_toggle_use_extern_curves__i(Fl_Check_Button* o, void*) {
  theBr2Hdr.setUseExternResponse(o->value());
}
void ResponseWinClass::cb_toggle_use_extern_curves_(Fl_Check_Button* o, void* v) {
  ((ResponseWinClass*)(o->parent()->parent()->user_data()))->cb_toggle_use_extern_curves__i(o,v);
}

void ResponseWinClass::cb_choice_plot__i(Fl_Choice* o, void*) {
  plot_->which_curves(Br2Hdr::WhichCurves(o->value()));
plot_->update();
update_save_menu();
}
void ResponseWinClass::cb_choice_plot_(Fl_Choice* o, void* v) {
  ((ResponseWinClass*)(o->parent()->user_data()))->cb_choice_plot__i(o,v);
}

Fl_Menu_Item ResponseWinClass::menu_choice_plot_[] = {
 {_("using next"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("computed"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("external"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("calctor\'s"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void ResponseWinClass::cb_All_i(Fl_Menu_*, void*) {
  load_all_response_curves_dialog();
}
void ResponseWinClass::cb_All(Fl_Menu_* o, void* v) {
  ((ResponseWinClass*)(o->parent()->user_data()))->cb_All_i(o,v);
}

void ResponseWinClass::cb_R_i(Fl_Menu_*, void*) {
  load_response_curve_dialog (0);
}
void ResponseWinClass::cb_R(Fl_Menu_* o, void* v) {
  ((ResponseWinClass*)(o->parent()->user_data()))->cb_R_i(o,v);
}

void ResponseWinClass::cb_G_i(Fl_Menu_*, void*) {
  load_response_curve_dialog (1);
}
void ResponseWinClass::cb_G(Fl_Menu_* o, void* v) {
  ((ResponseWinClass*)(o->parent()->user_data()))->cb_G_i(o,v);
}

void ResponseWinClass::cb_B_i(Fl_Menu_*, void*) {
  load_response_curve_dialog (2);
}
void ResponseWinClass::cb_B(Fl_Menu_* o, void* v) {
  ((ResponseWinClass*)(o->parent()->user_data()))->cb_B_i(o,v);
}

Fl_Menu_Item ResponseWinClass::menu_Load[] = {
 {_("All channels"), 0,  (Fl_Callback*)ResponseWinClass::cb_All, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("R channel"), 0,  (Fl_Callback*)ResponseWinClass::cb_R, 0, 0, FL_NORMAL_LABEL, 0, 14, 1},
 {_("G channel"), 0,  (Fl_Callback*)ResponseWinClass::cb_G, 0, 0, FL_NORMAL_LABEL, 0, 14, 61},
 {_("B channel"), 0,  (Fl_Callback*)ResponseWinClass::cb_B, 0, 0, FL_NORMAL_LABEL, 0, 14, 177},
 {0,0,0,0,0,0,0,0,0}
};

void ResponseWinClass::cb_All1_i(Fl_Menu_*, void*) {
  save_response_curves_dialog(plot().which_curves(), -1);
}
void ResponseWinClass::cb_All1(Fl_Menu_* o, void* v) {
  ((ResponseWinClass*)(o->parent()->user_data()))->cb_All1_i(o,v);
}

void ResponseWinClass::cb_menubttn_save_item_channel_0_i(Fl_Menu_*, void*) {
  save_response_curves_dialog (plot().which_curves(), 0);
}
void ResponseWinClass::cb_menubttn_save_item_channel_0(Fl_Menu_* o, void* v) {
  ((ResponseWinClass*)(o->parent()->user_data()))->cb_menubttn_save_item_channel_0_i(o,v);
}

void ResponseWinClass::cb_menubttn_save_item_channel_1_i(Fl_Menu_*, void*) {
  save_response_curves_dialog (plot().which_curves(), 1);
}
void ResponseWinClass::cb_menubttn_save_item_channel_1(Fl_Menu_* o, void* v) {
  ((ResponseWinClass*)(o->parent()->user_data()))->cb_menubttn_save_item_channel_1_i(o,v);
}

void ResponseWinClass::cb_menubttn_save_item_channel_2_i(Fl_Menu_*, void*) {
  save_response_curves_dialog (plot().which_curves(), 2);
}
void ResponseWinClass::cb_menubttn_save_item_channel_2(Fl_Menu_* o, void* v) {
  ((ResponseWinClass*)(o->parent()->user_data()))->cb_menubttn_save_item_channel_2_i(o,v);
}

Fl_Menu_Item ResponseWinClass::menu_menubttn_save_[] = {
 {_("All channels"), 0,  (Fl_Callback*)ResponseWinClass::cb_All1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("R channel"), 0,  (Fl_Callback*)ResponseWinClass::cb_menubttn_save_item_channel_0, 0, 0, FL_NORMAL_LABEL, 0, 14, 1},
 {_("G channel"), 0,  (Fl_Callback*)ResponseWinClass::cb_menubttn_save_item_channel_1, 0, 0, FL_NORMAL_LABEL, 0, 14, 61},
 {_("B channel"), 0,  (Fl_Callback*)ResponseWinClass::cb_menubttn_save_item_channel_2, 0, 0, FL_NORMAL_LABEL, 0, 14, 177},
 {0,0,0,0,0,0,0,0,0}
};
Fl_Menu_Item* ResponseWinClass::menubttn_save_item_channel_0 = ResponseWinClass::menu_menubttn_save_ + 1;
Fl_Menu_Item* ResponseWinClass::menubttn_save_item_channel_1 = ResponseWinClass::menu_menubttn_save_ + 2;
Fl_Menu_Item* ResponseWinClass::menubttn_save_item_channel_2 = ResponseWinClass::menu_menubttn_save_ + 3;

void ResponseWinClass::cb_button_extern_all__i(Fl_Button*, void*) {
  applyResponseCurveExtern(-1);
}
void ResponseWinClass::cb_button_extern_all_(Fl_Button* o, void* v) {
  ((ResponseWinClass*)(o->parent()->parent()->user_data()))->cb_button_extern_all__i(o,v);
}

void ResponseWinClass::cb_button_computed_all__i(Fl_Button*, void*) {
  applyResponseCurveComputed(-1);
}
void ResponseWinClass::cb_button_computed_all_(Fl_Button* o, void* v) {
  ((ResponseWinClass*)(o->parent()->parent()->user_data()))->cb_button_computed_all__i(o,v);
}

void ResponseWinClass::cb_radio_computed__i(Fl_Light_Button*, void*) {
  applyResponseCurveComputed(0);
}
void ResponseWinClass::cb_radio_computed_(Fl_Light_Button* o, void* v) {
  ((ResponseWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_radio_computed__i(o,v);
}

void ResponseWinClass::cb_radio_extern__i(Fl_Light_Button*, void*) {
  applyResponseCurveExtern(0);
}
void ResponseWinClass::cb_radio_extern_(Fl_Light_Button* o, void* v) {
  ((ResponseWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_radio_extern__i(o,v);
}

void ResponseWinClass::cb_radio_computed_1_i(Fl_Light_Button*, void*) {
  applyResponseCurveComputed(1);
}
void ResponseWinClass::cb_radio_computed_1(Fl_Light_Button* o, void* v) {
  ((ResponseWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_radio_computed_1_i(o,v);
}

void ResponseWinClass::cb_radio_extern_1_i(Fl_Light_Button*, void*) {
  applyResponseCurveExtern(1);
}
void ResponseWinClass::cb_radio_extern_1(Fl_Light_Button* o, void* v) {
  ((ResponseWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_radio_extern_1_i(o,v);
}

void ResponseWinClass::cb_radio_computed_2_i(Fl_Light_Button*, void*) {
  applyResponseCurveComputed(2);
}
void ResponseWinClass::cb_radio_computed_2(Fl_Light_Button* o, void* v) {
  ((ResponseWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_radio_computed_2_i(o,v);
}

void ResponseWinClass::cb_radio_extern_2_i(Fl_Light_Button*, void*) {
  applyResponseCurveExtern(2);
}
void ResponseWinClass::cb_radio_extern_2(Fl_Light_Button* o, void* v) {
  ((ResponseWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_radio_extern_2_i(o,v);
}

ResponseWinClass::ResponseWinClass() {
  { window_ = new Fl_Double_Window(390, 505, _("Response Curves (Br2HDR)"));
    window_->user_data((void*)(this));
    { plot_ = new ResponsePlot(0, 0, 390, 310);
      plot_->tooltip(_("Red, green, blue the (inverse) response curves for the R, G, B channel: expos\
ure X over pixel value z. White the weight function for HDR-merging, dark gray\
 the weight function for response computation (the white can hide the dark). -\
-- Type \"1\", \"2\"... to see the single curves, \"0\" shows all."));
      plot_->box(FL_FLAT_BOX);
      plot_->color(FL_BACKGROUND_COLOR);
      plot_->selection_color(FL_BACKGROUND_COLOR);
      plot_->labeltype(FL_NORMAL_LABEL);
      plot_->labelfont(0);
      plot_->labelsize(14);
      plot_->labelcolor(FL_FOREGROUND_COLOR);
      plot_->align(FL_ALIGN_CENTER);
      plot_->when(FL_WHEN_RELEASE);
      plot_->end();
      Fl_Group::current()->resizable(plot_);
    } // ResponsePlot* plot_
    { Fl_Group* o = new Fl_Group(-5, 310, 400, 95);
      o->box(FL_ENGRAVED_FRAME);
      { Fl_Value_Slider* o = slider_grid_points_ = new Fl_Value_Slider(80, 320, 305, 20, _("Spot Points"));
        slider_grid_points_->tooltip(_("Number of spots to select for response curve computation (vertical sections t\
hrough the follow-up curves diagram)"));
        slider_grid_points_->type(1);
        slider_grid_points_->color(FL_BACKGROUND2_COLOR);
        slider_grid_points_->minimum(2);
        slider_grid_points_->maximum(256);
        slider_grid_points_->step(1);
        slider_grid_points_->textsize(14);
        slider_grid_points_->callback((Fl_Callback*)cb_slider_grid_points_);
        slider_grid_points_->align(FL_ALIGN_LEFT);
        o->value(theBr2Hdr.nSelectPoints());
      } // Fl_Value_Slider* slider_grid_points_
      { Fl_Value_Slider* o = slider_smoothing_ = new Fl_Value_Slider(80, 345, 305, 20, _("Smoothing"));
        slider_smoothing_->tooltip(_("Smoothing coefficient for response curve computation"));
        slider_smoothing_->type(1);
        slider_smoothing_->color(FL_BACKGROUND2_COLOR);
        slider_smoothing_->maximum(100);
        slider_smoothing_->step(0.5);
        slider_smoothing_->textsize(14);
        slider_smoothing_->callback((Fl_Callback*)cb_slider_smoothing_);
        slider_smoothing_->align(FL_ALIGN_LEFT);
        o->value(theBr2Hdr.smoothing());
      } // Fl_Value_Slider* slider_smoothing_
      { ComputeResponseButton* o = new ComputeResponseButton(240, 370, 140, 25, _("Compute Response"));
        o->tooltip(_("Compute the response curves"));
        o->box(FL_UP_BOX);
        o->color(FL_BACKGROUND_COLOR);
        o->selection_color(FL_BACKGROUND_COLOR);
        o->labeltype(FL_NORMAL_LABEL);
        o->labelfont(0);
        o->labelsize(14);
        o->labelcolor(FL_FOREGROUND_COLOR);
        o->align(FL_ALIGN_CENTER);
        o->when(FL_WHEN_RELEASE);
        o->extra_init();
      } // ComputeResponseButton* o
      { Fl_Check_Button* o = toggle_use_extern_curves_ = new Fl_Check_Button(10, 375, 175, 20, _("Use external curves"));
        toggle_use_extern_curves_->tooltip(_("Deactivate the response curve computing stuff"));
        toggle_use_extern_curves_->down_box(FL_DOWN_BOX);
        toggle_use_extern_curves_->callback((Fl_Callback*)cb_toggle_use_extern_curves_);
        o->value(theBr2Hdr.isUseExternResponse());
      } // Fl_Check_Button* toggle_use_extern_curves_
      o->end();
    } // Fl_Group* o
    { Fl_Choice* o = choice_plot_ = new Fl_Choice(290, 425, 95, 25, _("Plotted:"));
      choice_plot_->tooltip(_("Select the curves to plot"));
      choice_plot_->down_box(FL_BORDER_BOX);
      choice_plot_->callback((Fl_Callback*)cb_choice_plot_);
      choice_plot_->menu(menu_choice_plot_);
      fl_translate_menu((Fl_Menu_Item*)o->menu());
    } // Fl_Choice* choice_plot_
    { Fl_Menu_Button* o = new Fl_Menu_Button(105, 475, 90, 25, _("Load"));
      o->tooltip(_("Load external response curves from file. For \"load all\" the filename ending\
s \"_R\", \"_G_\", \"_B\" are handled automatically (removed & completed)."));
      o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
      o->menu(menu_Load);
      fl_translate_menu((Fl_Menu_Item*)o->menu());
    } // Fl_Menu_Button* o
    { Fl_Menu_Button* o = menubttn_save_ = new Fl_Menu_Button(205, 475, 90, 25, _("Save"));
      menubttn_save_->tooltip(_("Save the PLOTTED response curves to file. The filenames are completed automat\
ically by the channel endings \"_R\", \"_G\", \"_B\"."));
      menubttn_save_->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
      menubttn_save_->menu(menu_menubttn_save_);
      fl_translate_menu ((Fl_Menu_Item*)o->menu());
    } // Fl_Menu_Button* menubttn_save_
    { group_using_next_ = new Fl_Group(5, 408, 200, 64);
      group_using_next_->tooltip(_("Select the response curves using next for HDR merging"));
      group_using_next_->deactivate();
      { new Fl_Box(35, 409, 145, 16, _("Curves using next:"));
      } // Fl_Box* o
      { button_extern_all_ = new Fl_Button(5, 450, 75, 20, _("external:"));
        button_extern_all_->tooltip(_("Make all external response curves to \"using next\" curves"));
        button_extern_all_->box(FL_THIN_UP_BOX);
        button_extern_all_->callback((Fl_Callback*)cb_button_extern_all_);
        button_extern_all_->align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE);
      } // Fl_Button* button_extern_all_
      { button_computed_all_ = new Fl_Button(5, 425, 75, 20, _("computed:"));
        button_computed_all_->tooltip(_("Make all computed response curves to \"using next\" curves"));
        button_computed_all_->box(FL_THIN_UP_BOX);
        button_computed_all_->callback((Fl_Callback*)cb_button_computed_all_);
        button_computed_all_->align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE);
      } // Fl_Button* button_computed_all_
      { Fl_Group* o = new Fl_Group(80, 424, 40, 46);
        { radio_computed_[0] = new Fl_Light_Button(80, 425, 40, 20, _("R"));
          radio_computed_[0]->type(102);
          radio_computed_[0]->selection_color((Fl_Color)3);
          radio_computed_[0]->labelcolor((Fl_Color)1);
          radio_computed_[0]->callback((Fl_Callback*)cb_radio_computed_);
          radio_computed_[0]->when(FL_WHEN_RELEASE_ALWAYS);
        } // Fl_Light_Button* radio_computed_[0]
        { radio_extern_[0] = new Fl_Light_Button(80, 450, 40, 20, _("R"));
          radio_extern_[0]->type(102);
          radio_extern_[0]->selection_color((Fl_Color)3);
          radio_extern_[0]->labelcolor((Fl_Color)1);
          radio_extern_[0]->callback((Fl_Callback*)cb_radio_extern_);
          radio_extern_[0]->when(FL_WHEN_RELEASE_ALWAYS);
        } // Fl_Light_Button* radio_extern_[0]
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(120, 424, 40, 46);
        { radio_computed_[1] = new Fl_Light_Button(120, 425, 40, 20, _("G"));
          radio_computed_[1]->type(102);
          radio_computed_[1]->labelcolor((Fl_Color)61);
          radio_computed_[1]->callback((Fl_Callback*)cb_radio_computed_1);
          radio_computed_[1]->when(FL_WHEN_RELEASE_ALWAYS);
        } // Fl_Light_Button* radio_computed_[1]
        { radio_extern_[1] = new Fl_Light_Button(120, 450, 40, 20, _("G"));
          radio_extern_[1]->type(102);
          radio_extern_[1]->labelcolor((Fl_Color)61);
          radio_extern_[1]->callback((Fl_Callback*)cb_radio_extern_1);
          radio_extern_[1]->when(FL_WHEN_RELEASE_ALWAYS);
        } // Fl_Light_Button* radio_extern_[1]
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(160, 424, 40, 46);
        { radio_computed_[2] = new Fl_Light_Button(160, 425, 40, 20, _("B"));
          radio_computed_[2]->type(102);
          radio_computed_[2]->labelcolor((Fl_Color)4);
          radio_computed_[2]->callback((Fl_Callback*)cb_radio_computed_2);
          radio_computed_[2]->when(FL_WHEN_RELEASE_ALWAYS);
        } // Fl_Light_Button* radio_computed_[2]
        { radio_extern_[2] = new Fl_Light_Button(160, 450, 40, 20, _("B"));
          radio_extern_[2]->type(102);
          radio_extern_[2]->labelcolor((Fl_Color)4);
          radio_extern_[2]->callback((Fl_Callback*)cb_radio_extern_2);
          radio_extern_[2]->when(FL_WHEN_RELEASE_ALWAYS);
        } // Fl_Light_Button* radio_extern_[2]
        o->end();
      } // Fl_Group* o
      group_using_next_->end();
    } // Fl_Group* group_using_next_
    update_activation_radios_Computed();
    update_activation_radios_External();
    update_save_menu();
    window_->end();
  } // Fl_Double_Window* window_
}

void ResponseWinClass::show() {
  window_->show();
}

Fl_Window* ResponseWinClass::window() {
  return window_;
}

ResponsePlot & ResponseWinClass::plot() {
  return *plot_;
}

void FollowUpWinClass::cb_Ref_i(RefpicChoicer* o, void*) {
  theBr2Hdr.set_refpic(o->value());
}
void FollowUpWinClass::cb_Ref(RefpicChoicer* o, void* v) {
  ((FollowUpWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_Ref_i(o,v);
}

void FollowUpWinClass::cb_Channel_i(Fl_Choice* o, void*) {
  plot_->set_channel(o->value());
plot_->update();
}
void FollowUpWinClass::cb_Channel(Fl_Choice* o, void* v) {
  ((FollowUpWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_Channel_i(o,v);
}

Fl_Menu_Item FollowUpWinClass::menu_Channel[] = {
 {_("R"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 1},
 {_("G"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 61},
 {_("B"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 4},
 {0,0,0,0,0,0,0,0,0}
};

FollowUpWinClass::FollowUpWinClass() {
  { Fl_Double_Window* o = window_ = new Fl_Double_Window(520, 415, _("Follow-up Curves (Br2HDR)"));
    window_->user_data((void*)(this));
    window_->align(FL_ALIGN_TOP|FL_ALIGN_INSIDE);
    { plot_ = new FollowUpCurvePlot(0, 1, 520, 377);
      plot_->tooltip(_("Follow-up curves for the chosen reference image and channel"));
      plot_->box(FL_FLAT_BOX);
      plot_->color((Fl_Color)48);
      plot_->selection_color(FL_BACKGROUND_COLOR);
      plot_->labeltype(FL_NORMAL_LABEL);
      plot_->labelfont(0);
      plot_->labelsize(14);
      plot_->labelcolor(FL_FOREGROUND_COLOR);
      plot_->align(FL_ALIGN_TOP);
      plot_->when(FL_WHEN_RELEASE);
      plot_->end();
    } // FollowUpCurvePlot* plot_
    { Fl_Group* o = new Fl_Group(-5, 380, 530, 40);
      o->box(FL_ENGRAVED_FRAME);
      { Fl_Group* o = new Fl_Group(65, 385, 444, 30);
        { RefpicChoicer* o = new RefpicChoicer(70, 385, 55, 25, _("Ref-Img"));
          o->tooltip(_("Reference image for calculation of follow-up curves"));
          o->box(FL_FLAT_BOX);
          o->down_box(FL_BORDER_BOX);
          o->color(FL_BACKGROUND_COLOR);
          o->selection_color(FL_SELECTION_COLOR);
          o->labeltype(FL_NORMAL_LABEL);
          o->labelfont(0);
          o->labelsize(14);
          o->labelcolor(FL_FOREGROUND_COLOR);
          o->callback((Fl_Callback*)cb_Ref);
          o->align(FL_ALIGN_LEFT);
          o->when(FL_WHEN_RELEASE);
        } // RefpicChoicer* o
        { Fl_Choice* o = new Fl_Choice(200, 385, 50, 25, _("Channel"));
          o->tooltip(_("Channel for which follow-up curves shall be displayed"));
          o->down_box(FL_BORDER_BOX);
          o->callback((Fl_Callback*)cb_Channel);
          o->menu(menu_Channel);
        } // Fl_Choice* o
        { ComputeFllwUpButton* o = new ComputeFllwUpButton(395, 385, 114, 25, _("Compute"));
          o->tooltip(_("Compute follow-up curves"));
          o->box(FL_UP_BOX);
          o->color(FL_BACKGROUND_COLOR);
          o->selection_color(FL_BACKGROUND_COLOR);
          o->labeltype(FL_NORMAL_LABEL);
          o->labelfont(0);
          o->labelsize(14);
          o->labelcolor(FL_FOREGROUND_COLOR);
          o->align(FL_ALIGN_CENTER);
          o->when(FL_WHEN_RELEASE);
          o->extra_init();
        } // ComputeFllwUpButton* o
        o->end();
      } // Fl_Group* o
      o->end();
    } // Fl_Group* o
    o->resizable(plot_);
    window_->end();
  } // Fl_Double_Window* window_
}

FollowUpWinClass::~FollowUpWinClass() {
  delete window_;
}

void FollowUpWinClass::show() {
  window_->show();
}

Fl_Window* FollowUpWinClass::window() {
  return window_;
}

void TestSuiteWinClass::cb_window__i(Fl_Double_Window* o, void*) {
  o->hide();
WidgetWrapper::delete_wrapper(this);
}
void TestSuiteWinClass::cb_window_(Fl_Double_Window* o, void* v) {
  ((TestSuiteWinClass*)(o->user_data()))->cb_window__i(o,v);
}

Fl_Menu_Item TestSuiteWinClass::menu_choice_scene_[] = {
 {_("XY-Slope"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Random Values"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Menu_Item TestSuiteWinClass::menu_choice_response_[] = {
 {_("Linear"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("Cosinus"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void TestSuiteWinClass::cb_bttn_add__i(Fl_Button*, void*) {
  if (check_clear_old_->value())
  m_Br2Hdr.clear_ContAndCalc();
  
do_add();
}
void TestSuiteWinClass::cb_bttn_add_(Fl_Button* o, void* v) {
  ((TestSuiteWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_bttn_add__i(o,v);
}

void TestSuiteWinClass::cb_bttn_add_simple__i(Fl_Button*, void*) {
  if (check_clear_old_->value())
  m_Br2Hdr.clear_ContAndCalc();
  
add_TestImages (m_Br2Hdr,
  int(input_xdim_->value()+0.5),
  int(input_ydim_->value()+0.5),
  int(input_N_->value()+0.5),
  ImageType(choice_data_type_->value()+1));
}
void TestSuiteWinClass::cb_bttn_add_simple_(Fl_Button* o, void* v) {
  ((TestSuiteWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_bttn_add_simple__i(o,v);
}

void TestSuiteWinClass::cb_Bad_i(Fl_Button*, void*) {
  if (check_clear_old_->value())
  m_Br2Hdr.clear_ContAndCalc();
  
add_BadImages (m_Br2Hdr,
  int(input_xdim_->value()+0.5),
  int(input_ydim_->value()+0.5),
  int(input_N_->value()+0.5),
  ImageType(choice_data_type_->value()+1));
}
void TestSuiteWinClass::cb_Bad(Fl_Button* o, void* v) {
  ((TestSuiteWinClass*)(o->parent()->parent()->parent()->user_data()))->cb_Bad_i(o,v);
}

Fl_Menu_Item TestSuiteWinClass::menu_choice_data_type_[] = {
 {_("uint8"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("uint16"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

TestSuiteWinClass::TestSuiteWinClass(br::Br2HdrManager& m) : m_Br2Hdr(m) {
// Wenn doch nicht lokal, "theBr2Hdr" benutzen!
  init_params();
  { window_ = new Fl_Double_Window(535, 305, _("TestSuite (Br2HDR)"));
    window_->callback((Fl_Callback*)cb_window_, (void*)(this));
    { Fl_Tabs* o = new Fl_Tabs(0, 0, 535, 310);
      o->selection_color(FL_BACKGROUND2_COLOR);
      { Fl_Group* o = new Fl_Group(0, 25, 535, 275, _("Add Test Images"));
        o->tooltip(_("Create a simulated series of bracketed exposures and add it to the image cont\
ainer. The therein used exposure times correspond a \'stop\' value of 1."));
        { input_xdim_ = new Fl_IntInput_Slider(70, 170, 445, 20, _("x-dim"));
          input_xdim_->tooltip(_("x-dimension of the images"));
          input_xdim_->type(1);
          input_xdim_->box(FL_DOWN_BOX);
          input_xdim_->color(FL_BACKGROUND2_COLOR);
          input_xdim_->selection_color(FL_BACKGROUND_COLOR);
          input_xdim_->labeltype(FL_NORMAL_LABEL);
          input_xdim_->labelfont(0);
          input_xdim_->labelsize(14);
          input_xdim_->labelcolor(FL_FOREGROUND_COLOR);
          input_xdim_->minimum(1);
          input_xdim_->maximum(3000);
          input_xdim_->step(1);
          input_xdim_->value(200);
          input_xdim_->textsize(14);
          input_xdim_->align(FL_ALIGN_LEFT);
          input_xdim_->when(FL_WHEN_CHANGED);
        } // Fl_IntInput_Slider* input_xdim_
        { input_ydim_ = new Fl_IntInput_Slider(70, 200, 445, 20, _("y-dim"));
          input_ydim_->tooltip(_("y-dimension of the imagess"));
          input_ydim_->type(1);
          input_ydim_->box(FL_DOWN_BOX);
          input_ydim_->color(FL_BACKGROUND2_COLOR);
          input_ydim_->selection_color(FL_BACKGROUND_COLOR);
          input_ydim_->labeltype(FL_NORMAL_LABEL);
          input_ydim_->labelfont(0);
          input_ydim_->labelsize(14);
          input_ydim_->labelcolor(FL_FOREGROUND_COLOR);
          input_ydim_->minimum(1);
          input_ydim_->maximum(3000);
          input_ydim_->step(1);
          input_ydim_->value(200);
          input_ydim_->textsize(14);
          input_ydim_->align(FL_ALIGN_LEFT);
          input_ydim_->when(FL_WHEN_CHANGED);
        } // Fl_IntInput_Slider* input_ydim_
        { input_N_ = new Fl_Value_Slider(70, 235, 150, 20, _("Images"));
          input_N_->tooltip(_("Number of images of a series"));
          input_N_->type(1);
          input_N_->color(FL_BACKGROUND2_COLOR);
          input_N_->minimum(1);
          input_N_->maximum(15);
          input_N_->step(1);
          input_N_->value(3);
          input_N_->textsize(14);
          input_N_->align(FL_ALIGN_LEFT);
        } // Fl_Value_Slider* input_N_
        { check_clear_old_ = new Fl_Check_Button(20, 45, 240, 25, _("Clear image container before"));
          check_clear_old_->tooltip(_("Clear image container before adding"));
          check_clear_old_->down_box(FL_DOWN_BOX);
          check_clear_old_->value(1);
        } // Fl_Check_Button* check_clear_old_
        { Fl_Choice* o = choice_scene_ = new Fl_Choice(140, 95, 95, 25, _("Radiance Scene"));
          choice_scene_->tooltip(_("Simulated Radiance Scene"));
          choice_scene_->down_box(FL_BORDER_BOX);
          choice_scene_->menu(menu_choice_scene_);
          fl_translate_menu((Fl_Menu_Item*)o->menu());
        } // Fl_Choice* choice_scene_
        { Fl_Button* o = new Fl_Button(235, 95, 70, 25, _("Details..."));
          o->deactivate();
        } // Fl_Button* o
        { Fl_Choice* o = choice_response_ = new Fl_Choice(140, 125, 95, 25, _("Response Function"));
          choice_response_->tooltip(_("The (simulated) response function used for image generation"));
          choice_response_->down_box(FL_BORDER_BOX);
          choice_response_->menu(menu_choice_response_);
          fl_translate_menu((Fl_Menu_Item*)o->menu());
        } // Fl_Choice* choice_response_
        { Fl_Button* o = new Fl_Button(235, 125, 70, 25, _("Details..."));
          o->deactivate();
        } // Fl_Button* o
        { bttn_add_ = new Fl_Button(70, 270, 110, 25, _("Add"));
          bttn_add_->tooltip(_("Add the above specified test images"));
          bttn_add_->callback((Fl_Callback*)cb_bttn_add_);
        } // Fl_Button* bttn_add_
        { bttn_add_simple_ = new Fl_Button(285, 270, 110, 25, _("123... Images"));
          bttn_add_simple_->tooltip(_("Add images with 1,2,3... values"));
          bttn_add_simple_->callback((Fl_Callback*)cb_bttn_add_simple_);
        } // Fl_Button* bttn_add_simple_
        { Fl_Button* o = new Fl_Button(405, 270, 110, 25, _("Bad Images"));
          o->tooltip(_("Creates an image series, which produces an exception while response computati\
on."));
          o->callback((Fl_Callback*)cb_Bad);
        } // Fl_Button* o
        { choice_data_type_ = new Fl_Choice(420, 45, 75, 25, _("Data type"));
          choice_data_type_->tooltip(_("Data type of the images"));
          choice_data_type_->down_box(FL_BORDER_BOX);
          choice_data_type_->menu(menu_choice_data_type_);
        } // Fl_Choice* choice_data_type_
        o->end();
      } // Fl_Group* o
      o->end();
    } // Fl_Tabs* o
    window_->end();
    window_->resizable(window_);
  } // Fl_Double_Window* window_
}

TestSuiteWinClass::~TestSuiteWinClass() {
  delete window_;
}

void TestSuiteWinClass::show() {
  window_->show();
}

Fl_Window* TestSuiteWinClass::window() {
  return window_;
}

void HelpAboutWinClass::cb_Close_i(Fl_Button*, void*) {
  window_->do_callback();
}
void HelpAboutWinClass::cb_Close(Fl_Button* o, void* v) {
  ((HelpAboutWinClass*)(o->parent()->user_data()))->cb_Close_i(o,v);
}

HelpAboutWinClass::HelpAboutWinClass() {
  { Fl_Window* o = window_ = new Fl_Window(400, 245, _("About \"Bracketing to HDR\""));
    window_->user_data((void*)(this));
    { Fl_Box* o = new Fl_Box(30, 29, 340, 25);
      o->labelsize(21);
      static char s[80];
      sprintf(s,"\"%s\"  -  %s %s", _("Bracketing to HDR"), _("Version"), BR_VERSION_STRING);
      o->label(s);
    } // Fl_Box* o
    { Fl_Box* o = new Fl_Box(30, 55, 340, 25, _("Plugin for CinePaint"));
      o->labelsize(21);
    } // Fl_Box* o
    { new Fl_Box(92, 150, 215, 20, _("(c) 2005/06  Hartmut Sbosny"));
    } // Fl_Box* o
    { Fl_Output* o = new Fl_Output(107, 168, 185, 20);
      o->box(FL_FLAT_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->value(" <hartmut.sbosny@gmx.de>");
      o->clear_visible_focus();
    } // Fl_Output* o
    { Fl_Box* o = new Fl_Box(27, 94, 345, 42, _("Merges bracketed exposures of a (still) scene into one High Dynamic Range ima\
ge (radiance map)"));
      o->align(FL_ALIGN_WRAP);
    } // Fl_Box* o
    { Fl_Button* o = new Fl_Button(155, 210, 90, 25, _("Close"));
      o->callback((Fl_Callback*)cb_Close);
    } // Fl_Button* o
    o->position((Fl::w()-o->w())/2, (Fl::h()-o->h())/2);
    window_->end();
    window_->resizable(window_);
  } // Fl_Window* window_
}

HelpAboutWinClass::~HelpAboutWinClass() {
  delete window_;
}

Fl_Window* HelpAboutWinClass::window() {
  return window_;
}

void HelpTutorialWinClass::cb_Close1_i(Fl_Button*, void*) {
  window_->do_callback();
}
void HelpTutorialWinClass::cb_Close1(Fl_Button* o, void* v) {
  ((HelpTutorialWinClass*)(o->parent()->user_data()))->cb_Close1_i(o,v);
}

HelpTutorialWinClass::HelpTutorialWinClass() {
  { window_ = new Fl_Window(505, 245, _("HDR-Tutorial"));
    window_->user_data((void*)(this));
    { Fl_Box* o = new Fl_Box(20, 33, 330, 27, _("HDR-Tutorial..."));
      o->labelsize(18);
      o->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);
    } // Fl_Box* o
    { Fl_Box* o = new Fl_Box(20, 75, 380, 20, _("An english tutorial you will find at:"));
      o->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);
    } // Fl_Box* o
    { Fl_Output* o = new Fl_Output(20, 95, 470, 20);
      o->box(FL_FLAT_BOX);
      o->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);
      o->value(" http://freenet-homepage.de/hsbosny/HDR_Tutorial/HDR_Tutorial-en.html ");
      o->clear_visible_focus();
    } // Fl_Output* o
    { Fl_Output* o = new Fl_Output(20, 150, 470, 20);
      o->box(FL_FLAT_BOX);
      o->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);
      o->value(" http://freenet-homepage.de/hsbosny/HDR_Tutorial/HDR_Tutorial-de.html ");
      o->clear_visible_focus();
    } // Fl_Output* o
    { Fl_Box* o = new Fl_Box(20, 130, 380, 20, _("Eine deutsche Anleitung finden Sie unter:"));
      o->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);
    } // Fl_Box* o
    { Fl_Button* o = new Fl_Button(207, 210, 90, 25, _("Close"));
      o->callback((Fl_Callback*)cb_Close1);
    } // Fl_Button* o
    window_->end();
    window_->resizable(window_);
  } // Fl_Window* window_
}

HelpTutorialWinClass::~HelpTutorialWinClass() {
  delete window_;
}

Fl_Window* HelpTutorialWinClass::window() {
  return window_;
}

void HistogramWinClass::cb_window_1_i(Fl_Double_Window* o, void*) {
  o->hide();
WidgetWrapper::delete_wrapper(this);
}
void HistogramWinClass::cb_window_1(Fl_Double_Window* o, void* v) {
  ((HistogramWinClass*)(o->user_data()))->cb_window_1_i(o,v);
}

void HistogramWinClass::cb_Channel1_i(Fl_Choice* o, void*) {
  plot_->set_channel(o->value()-1);
plot_->update();
}
void HistogramWinClass::cb_Channel1(Fl_Choice* o, void* v) {
  ((HistogramWinClass*)(o->parent()->parent()->user_data()))->cb_Channel1_i(o,v);
}

Fl_Menu_Item HistogramWinClass::menu_Channel1[] = {
 {_("all"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {_("R"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 1},
 {_("G"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 61},
 {_("B"), 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 4},
 {0,0,0,0,0,0,0,0,0}
};

void HistogramWinClass::cb_choice_image__i(Fl_Choice* o, void*) {
  plot_->set_image(o->value());
plot_->update();
}
void HistogramWinClass::cb_choice_image_(Fl_Choice* o, void* v) {
  ((HistogramWinClass*)(o->parent()->parent()->user_data()))->cb_choice_image__i(o,v);
}

HistogramWinClass::HistogramWinClass() {
  { Fl_Double_Window* o = window_ = new Fl_Double_Window(450, 370, _("Histogram (Br2HDR)"));
    window_->callback((Fl_Callback*)cb_window_1, (void*)(this));
    { plot_ = new HistogramPlot(0, 0, 450, 335);
      plot_->tooltip(_("Histogram: percentage of pixels with value x"));
      plot_->box(FL_FLAT_BOX);
      plot_->color(FL_BACKGROUND_COLOR);
      plot_->selection_color(FL_BACKGROUND_COLOR);
      plot_->labeltype(FL_NORMAL_LABEL);
      plot_->labelfont(0);
      plot_->labelsize(14);
      plot_->labelcolor(FL_FOREGROUND_COLOR);
      plot_->align(FL_ALIGN_TOP);
      plot_->when(FL_WHEN_RELEASE);
      plot_->end();
    } // HistogramPlot* plot_
    { Fl_Group* o = new Fl_Group(-5, 335, 465, 40);
      o->box(FL_ENGRAVED_FRAME);
      { Fl_Choice* o = new Fl_Choice(175, 340, 50, 25, _("Channel"));
        o->tooltip(_("Channel for which histogram shall be displayed"));
        o->down_box(FL_BORDER_BOX);
        o->callback((Fl_Callback*)cb_Channel1);
        o->menu(menu_Channel1);
        fl_translate_menu((Fl_Menu_Item*)o->menu());
      } // Fl_Choice* o
      { choice_image_ = new Fl_Choice(55, 340, 50, 25, _("Image"));
        choice_image_->down_box(FL_BORDER_BOX);
        choice_image_->callback((Fl_Callback*)cb_choice_image_);
        choice_image_->when(FL_WHEN_RELEASE_ALWAYS);
        build_choice_image();
      } // Fl_Choice* choice_image_
      o->end();
    } // Fl_Group* o
    o->resizable(plot_);
    window_->end();
  } // Fl_Double_Window* window_
}

HistogramWinClass::~HistogramWinClass() {
  delete window_;
}

Fl_Window* HistogramWinClass::window() {
  return window_;
}
#include "gui_rest.cpp"
